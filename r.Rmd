# (PART) R {-}






# R language



## Tips

- export Excel: `writexl::write_xlsx()`
- `match.arg()`
- `ctrl+l` clear console
- `remotes::package_deps(.packages(T)) %>% tibble::as_tibble()`



### style

- only use `<-` for
  1. function definition
  2. initialize varible, especially when definition is far from first usage (initialize means you create the varible only once)
  3. `foobar(...) <- value`, though it's okay to use `=`, but modifing arguments using function is rare in R, so use `<-` can help you remind what you are doing and be consistency with how the function is defined



### Unnoticed feature

```{r}
as.character(NA) %T>% print %>% class()

as.character(NULL) %T>% print %>% class()
```

```{r}
0xFfE4
```



### Statistics

```r
?e1071::skewness
?e1071::kurtosis

?TukeyHSD
```






## function, evaluation, environment



### core rules

1. lazy evaluation to decide when to evaluate the parameter, 
2. call stack to decide where (start point) to evaluate the argument
3. lexically scoping to where to find undefined symbol in the argument



### lazy evaluation

```{r}
f <- function(x) {y <- 1; message('in f()'); x;}

f(message('evaluate argument'))
```

In `f()`, the parameter `x` is not evaluated until it's used, i.e., after `message('in f()')`.


```{r}
f <- function(x) {message('in f()'); g(x)}
g <- function(x) {message('in g()'); x}

f(message('evaluate argument'))
```

In `f()`, passing the parameter `x` as argument for `g()` doesn't evaluate it.



### call stack

```{r}
f <- function(x) {message('in f()'); g(x)}
g <- function(x) {message('in g()'); y <- 2; x}

y <- 1
f(message('y = ', y))
```

We already know that, `message('y = ', y)` is lazy evaluated after `y <- 2` inside `g()`. However，when the evaluation happens, the stage is NOT the execution env of `g()`. Rather, we start from there, backtrack the call stack,  until we arrive the start point, i.e., the caller env of `f()` (the global env here).



### lexically scoping

```{r}
g <- function(u) (u + v) / 2  
h <- function(u) {
    v <- 1  
    g(u)    
}    
v <- 2  
h(10)
```

Although `g()` is called inside `h()`, it finds `v` in where it's defined, i.e., the global env.

Actually, lexically scoping is not a special rule, and the implemention is rather straightforward. The execution environment's parent is function environment, i.e., when the function is created. So we just need to follow the general rule of parent environment.


### technical details

1. the evaluation of argument happens only once, refer to [here](https://bookdown.dongzhuoer.com/hadley/adv-r/lazy-evaluation.html#promises) 
1. call stack is implemented in that a frame's parent is the previous frame, refer to [here](https://bookdown.dongzhuoer.com/hadley/adv-r/call-stack.html#frames)
1. when you write a function factory, you may need to [force evaluation](https://bookdown.dongzhuoer.com/hadley/adv-r/factory-fundamentals.html#forcing-evaluation)






## install packages



### Bioconductor

If you want use a particular Bioconductor version, say 3.7, `BiocManager::install(version = '3.7')`. 

As a special case, **remotes** allows you specify a certain Bioconductor version when installing packages, like `remotes::install_bioc('3.7/ggtree')`. However, this only works _package-wise_, i,e, if you install other package, it still use the default Bioconductor version ^[At the time of this writing, `remotes::install_bioc('clusterProfiler')` would use Bioconductor 3.8]. 



### Administration and Maintances of R Packages

1. `/usr/lib/R/library` should keep clean, which makes it very convenient to update or reinstall R.
1. `/usr/lib/R/site-library` is useful when there are many users, and they all need many common packages. ^[Another example is a server with Shiny Server installed. There `root` may need some packages for Shiny apps hosted. And the normal user can also use these packages, although he may not need.]
1. `/usr/local/lib/R/site-library` should be removed ^[I get duplicated packages when I use `source("https://install-github.me/username/repo")`].
1. user library, I prefer to use `~/.local/lib/R` ^[add `R_LIBS_USER="~/.local/lib/R"` in `~/.Renviron`], although RStudio's default is `/home/${USER}/R/x86_64-pc-linux-gnu-library/3.4`.






## Rcpp basics



### core idea

only use Rcpp as a tool to _pass_ object:

1. write your code logical in C++ way, use STL as much as possible
1. only use Rcpp function for very simple operation, like `.size()`, `[i]`



### complier options

There are two files:

- `~/.R/Makevars` specifies how you build source package and standalone C++ file
- `src/Makevars`  specifies how your package is built by others

Typically, you can use `~/.R/Makevars` to switch which complier to use [^choose-compiler]: 

```
CC=clang
CXX17 = clang++
```

while C++ version (like C++17) should be specified per `.cpp` file using `// [[Rcpp::plugins(cpp17)]]`, since you can't determine which version others' code conform to.

[^choose-compiler]:
    Formerly I use

    ```
    CC=clang
    CXX   = clang++
    CXX98 = clang++
    CXX11 = clang++
    CXX14 = clang++
    CXX17 = clang++
    CXX1X = clang++
    ```
    
    But later I found some packages is only compatible with `g++` (such as DropletUtils 1.2.2), so I choose to only use `clang++` for C++17, assuming that those bad packages won't use latest standard (while myself always do that)



### Rcpp internals

1. `IntegerVector` 等都可以看作是 shadow copy，记住不能 move






## Rcpp Advanced



### current limit

1. pure C++ function can't be exported. 
   Since you can only export R version or R & C++ version, but functions like `void foo(std::list<int> bar)` can't convert to R version.
1. exporting a header file which depends on a header file from another package is impossible ^[for **paristools**, the final solution is to give up exporting anything in header file. Since we find we needn't export functions like `as_locs()` at all, we needn't export the defination of custom struct. 

   in a standalone file
   
   ```
   // [[Rcpp::depends(paristools)]]
   #include <paristools.h>
   ```
   
   would cause
   
   ```
   In file included from /home/zhuoer/.local/lib/R/paristools/include/paristools.h:7:
   /home/zhuoer/.local/lib/R/paristools/include/paristools.hpp:4:10: fatal error: 'Rcppzhuoer.h' file not found
   #include <Rcppzhuoer.h>
            ^~~~~~~~~~~~~~
   ```
   
   That's because although **paristools** depends on **Rcppzhuoer**, `Rcpp::depends()` only adds the former to include path.

   The situation is better if you use `<paristools.h>` in a package, since `LinkingTo` is recursive


1. **testthat** can't test C++ export

   Rcpp use `find.package()` to determine package path, when you use testthat `find.package('pkg')` return the project dir (in normal session, it return package in the library, `.local/lib/R/pkg`). The reason is that `find.package()` looks for loaded namesace first, and testthat load pkg namespace from the the project dir. [^debug-testthat-cpp-export]
   
   A work-around is to use `callr::r()`.
  


### 坑边杂谈

以下为作死记录，可能会移到 blog

1. 标准库和编译器对右值的优化根本轮不到我来操心

   刚开始写 Rcpp 时，我很在意效率，甚至还返回右值引用等，结果还招致了 `complier warning`，查了半天资料还去不掉。最后我放弃了，改为写了一个 `struct`, `Rcppzhuoer::foo`, 其移动构造、复制都会打印一条消息，用来检测有没有浪费。比如我要用到如下的自定义类型，就把 `Rcppzhuoer::foo` 作为一个成员。结果根本没有一点浪费，只需要在必要的时候加上 `std::move()` 就好了

   ```cpp
   struct bar {
       std::string messsage {};
       int count {};
       Rcppzhuoer::foo<void> foo1 {}; // comment me in release
   };
   ```

1. 想用新标准，还是 std 大法好

   之前启用 C++17 时，我曾用 `grep "std=" /usr/lib/R/etc/Makeconf` 来搜索 R 定义的 alias，然后把 `PKG_CXXFLAGS = $(CXX17STD)` 添加到 `src/Makevars` 文件。但是 R 手册[提到](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Using-Makevars)
   
   > It should be written if at all possible in a portable style, in particular (except for `Makevars.win`) without the use of GNU extensions.  
   
   而 `CXX17STD = -std=gnu++17`，所以我就改为直接用 `PKG_CXXFLAGS = -std=c++17` 了

1. `Rcpp::plugins()` 没毛病

   之前用不了 clang++，我翻出了 `// [[Rcpp::plugins(cpp17)]]` 的源代码
   ```r
   .plugins[["cpp17"]] <- function() {
       if (getRversion() >= "3.4")         # with recent R versions, R can decide
           list(env = list(USE_CXX17 = "yes"))
       else
           list(env = list(PKG_CXXFLAGS ="-std=c++17"))
   }
   ```
   当时我觉得是 `USE_CXX17 = "yes"` 导致 Rcpp 只能使用 g++，还修改了 Rcpp 的源代码。后来看来，应该是我弄错了。这里把我翻到的代码贴出来，以便以后查阅。

1. debug why **testthat** can't test C++ export 

   Thanks for `verbose = T`, I find the code doesn't include `#include <paristools.h>` (later I find Rcpp can't find the file, so it doesn't include). After set `includes` parameter, still fail. 
   
   Thanks for `cacheDir = 'tests/testthat'`, I can get the temp `.cpp` file, and directly run `clang++` command. Finally, I found the cause.






## forcats

```{r message=FALSE}
library(tidyverse)
```

**factors** aims to handle categorical variables, i.e., `factor` class in R.

Here we explain two reordering functions.



### `forcats::fct_reorder(f, x)`   

each level is associated with a `x` value (if multiple, use a function such as `median()` to generate a single value), the order is determined by sorting the corresponding `x` value.

```{r fct-reorder, collapse=TRUE}
with(iris, forcats::fct_reorder(Species, Sepal.Width)) %>% levels

iris %>% group_by(Species) %>% summarise(Sepal.Width = median(Sepal.Width)) %>%
    arrange(Sepal.Width) %>% .$Species %>% as.character()
```

As you can see in following plot, `Species` has been reordered by median of `Sepal.Width`.

```{r fct-reorder-plot, fig.cap='forcats::fct_reorder()'}
cowplot::plot_grid(
    iris %>% 
        ggplot(aes(Species, Sepal.Width)) + geom_boxplot() + 
        labs(title = 'original'),
    iris %>% mutate(Species = forcats::fct_reorder(Species, Sepal.Width)) %>%
        ggplot(aes(Species, Sepal.Width)) + geom_boxplot() + 
        labs(title = 'reorder')
)
```
    


### `forcats::fct_reorder2(f, x, y)`  

Each level is associated with many `x` values and many `y` values, we use a function such as `max()` to select a `x` value, then we can get the corresponding `y` value. Now each level is associated with a single `y` value, and we can determine the order by sorting those `y` values. [^fct-reorder2-plot]

```{r fct-reorder2}
set.seed(0)
chkw <- ChickWeight %>% head(60) %>% mutate_at('Chick', forcats::fct_shuffle)


with(chkw, forcats::fct_reorder2(Chick, Time, weight)) %>% levels()

chkw %>% group_by(Chick) %>% arrange(desc(Time)) %>% slice(1) %>% ungroup() %>% 
    arrange(desc(weight)) %>% .$Chick %>% as.character()
```

As you can see in following plot, the vertical line (max `Time`), `Chick` has been reordered by `weight` at that line.

```{r fct-reorder2-plot, fig.cap='forcats::fct_reorder2()'}
cowplot::plot_grid(
    chkw %>% 
        ggplot(aes(Time, weight, colour = Chick)) + geom_point() + geom_line() + 
        geom_vline(xintercept = 21, alpha = 0.2) + labs(title = 'original'),
    chkw %>% mutate(Chick = forcats::fct_reorder2(Chick, Time, weight)) %>% 
        ggplot(aes(Time, weight, colour = Chick)) + geom_point() + geom_line() + 
        geom_vline(xintercept = 21, alpha = 0.2) + labs(title = 'reorder')
)
```







